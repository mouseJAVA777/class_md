# 사용자 프로세스 영역의 할당 방법 중 Contiguous Allocation에 대해 간단하게 설명하고, 2가지 방식을 적어주세요

- 메모리를 연속적으로 할당한다  
  2가지 방식 - 고정 분할, 가변 분할

# 외부단편화와 내부단편화에 대해서 설명하시오

- 외부단편화 - 분할된 메모리 구역이 프로세스가 올라가있지않아 사용될 수 있음에도 사용되어지지 않는 구역  
  내부단편화 - 메모리 구역에 프로세스가 올라와있음에도 사용되지 않는 구역

# 가상메모리가 나오게 된 이유(Motivation)를 서술하시오

- 기존에는 프로세스가 실행되는 코드의 전체를 메모리에 로드해야 했고, 메모리 용량보다 더 큰 프로그램은 실행시킬 수 없었다. 하지만 실제로는 코드의 일부에서만 대부분의 시간을 사용하고, 프로세스는 특정 순간에는 항상 작은 양의 주소 공간을 사용했기 때문에 이러한 방식은 매우 비효율적이었다.
  
  가상 메모리(Virtual Memory)는 이러한 물리적 메모리 크기의 한계를 극복하기 위해 나온 기술이다. 프로세스를 실행할 때 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 두는 것이다.

# 다이나믹 링킹이란?

- 라이브러리가 실행시 연결되는 기법 / 스태틱 링킹의 경우 라이브러리가 프로그램의 실행 파일 코드에 포함되기때문에, 실행 파일의 크기가 커짐 / 다이나믹의 경우 프로그램에 포함시켜 놓지 않기 때문에 자원을 아낄 수 있다.

# 비연속적 할당 방법에서 paging과 segmentation의 차이점은?

- paging - 프로세스를 일정한 크기(페이지 단위 4kb)로 나누는 Noncontiguous Allocation 방식  
  segmentation - 프로세스를 의미 단위로 나누는 것

# thrashing이란?

- page fault가 빈번하게 일어나는 현상  
  때문에 프로세스는 계속 페이지를 메모리에 올리려고 I/O만 진행하고 CPU가 놀기 때문에 OS가 MPD를 끌어올리기 위해 프로세스를 추가하여 page fault가 더 가속화되는 것

# CPU가 논리적 주소를 바라보는 이유는?

- ADD 20 30 처럼 instruction안 의 코드가 20, 30처럼 logical address로 되어있기에 CPU는 논리적 주소를 사용할 수 밖에 없다.

# clock algorithm에서 modified bit이 필요한 이유는?

- 조금 더 향상된 clock algorithm을 구성하기 위해  
  modified bit가 1이 되었다면, 메모리 올라와 OS에 의해 데이터가 변경되었다는 뜻이므로, backup disk에 새로운 값으로 갱신시켜주고 메모리에서 제거해야하기 때문이다.

# 2레벨 페이징에서 총 32bit는 각각 어떤 역할로 몇 개의 비트가 나누어지는가?

- 10 outer page table의 index  
  10 outer page table의 page에서의 offset  
  12 inner page(?) offset

# Page system에서는 LRU, LFU 등의 알고리즘이 사용될 수 없는 이유를 적고 대체 방안인 알고리즘의 이름을 적으시오.

- Page system은 하드웨어적으로 처리되기 때문에 OS가 관여하지않아 해당 페이지가 언제 참조되었는지, 얼마나 참조되었는지에 대한 정보를 알 수 없기 때문이다. 
  Clock Algorithm

# Clock Algorithm은 어떻게 LRU의 근사 알고리즘으로 볼 수 있는가?

- 가장 최근에 사용된 것이라면 reference bit가 1로 계속 유지되기 때문에 reference bit가 0인 것을 찾아 계속 도는 clock 알고리즘은 Least Recently Used 알고리즘과 비교하였을때 가장 최근에 사용되지 않은 페이지를 replace시킨다는 점에서 근사 알고리즘이라 볼 수 있다.
